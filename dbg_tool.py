"""
    Copyright 2025 Oleh Sharuda <oleh.sharuda@gmail.com>


    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 """
from config_file import BooKeeperConfig
from database import *
from tools import *
from logger import *
import pstats
import sys
from tabulate import tabulate
from colorama import Fore, Back, Style, init


OPT_DEL_DUP = '--del-dup'
OPT_EXT_STAT = '--ext-stat'
OPT_VALIDATE = '--validate'
OPT_CPROFILE = '--cprofile'
OPT_DB_STAT  = '--db_stat'


def help(exit_code: int, message=None):
    if message:
        print(f"{message}\n\n")
    print(f"""Program usage:
dbg_tool.py <config.json> <command>
Where command is one of the following:
{OPT_DEL_DUP} : Delete and report duplicates from book_files, archive_files and other_files tables.
{OPT_EXT_STAT} : Report statistics by extensions.
{OPT_VALIDATE} : Check and validate database.
{OPT_CPROFILE} : Dump 'scanstats' file generated by performance profiler.
{OPT_DB_STAT} : Dump database statistics.
""")

    quit(exit_code)


def check_params():
    if len(sys.argv) != 3:
        help(1, message="Wrong number of arguments.")

    available_options = {OPT_DEL_DUP, OPT_VALIDATE, OPT_EXT_STAT, OPT_CPROFILE, OPT_DB_STAT}
    if sys.argv[2] not in available_options:
        help(1, message="Bad command.")


#region DELETE DUPLICATES
def delete_duplicates_on_archive_files(db):
    query = """select archive_files.file_name, count(id) as cnt from archive_files group by file_name having cnt>1;"""
    cursor = db.get_sql_cursor(query)
    file_names = list()
    n = 0
    while True:
        row = cursor.fetchone()
        if not row:
            break
        file_names.append(row[0])
        n += 1
    cursor.close()

    delete_ids = list()
    for fn in file_names:
        fn = db.escape_string(fn)
        query = f"""select archive_files.id from archive_files where file_name='{fn}' order by archive_files.id;"""
        cursor = db.get_sql_cursor(query)
        res = cursor.fetchall()[1:]
        for fid in res:
            delete_ids.append(str(fid[0]))
        cursor.close()

    delete_statement = f"""delete from archive_files where archive_files.id in ({','.join(delete_ids)})"""
    db.execute(delete_statement)
    print(f'Archive files duplicates : {n} ({len(delete_ids)})')


def delete_duplicates_on_other_files(db):
    query = """select other_files.path_id, other_files.basename, count(id) as cnt from other_files group by other_files.path_id, other_files.basename having cnt>1;"""
    cursor = db.get_sql_cursor(query)
    to_delete = list()
    n = 0
    while True:
        row = cursor.fetchone()
        if not row:
            break
        to_delete.append((row[0], row[1]))
        n += 1
    cursor.close()

    delete_ids = list()
    for path_id, fn in to_delete:
        fn = db.escape_string(fn)
        query = f"""select other_files.id from other_files where file_name='{fn}' and path_id={path_id} order by other_files.id;"""
        cursor = db.get_sql_cursor(query)
        res = cursor.fetchall()[1:]
        for fid in res:
            delete_ids.append(str(fid[0]))
        cursor.close()

    delete_statement = f"""delete from other_files where other_files.id in ({','.join(delete_ids)})"""
    db.execute(delete_statement)
    print(f'Other files duplicates : {n} ({len(delete_ids)})')


def delete_duplicates_on_book_files(db):
    query = """select book_files.file_name, count(id) as cnt from book_files group by file_name having cnt>1;"""
    cursor = db.get_sql_cursor(query)
    file_names = list()
    n = 0
    while True:
        row = cursor.fetchone()
        if not row:
            break
        file_names.append(row[0])
        n += 1
    cursor.close()

    delete_ids = list()
    for fn in file_names:
        fn = db.escape_string(fn)
        query = f"""select book_files.id from book_files where file_name='{fn}' order by book_files.id;"""
        cursor = db.get_sql_cursor(query)
        res = cursor.fetchall()[1:]
        for fid in res:
            delete_ids.append(str(fid[0]))
        cursor.close()

    delete_statement = f"""delete from book_files where book_files.id in ({','.join(delete_ids)})"""
    db.execute(delete_statement)
    print(f'Book files duplicates : {n} ({len(delete_ids)})')


def delete_duplicates(db):
    delete_duplicates_on_book_files(db)
    delete_duplicates_on_archive_files(db)
    delete_duplicates_on_other_files(db)


#endregion

#region EXTENSION STATISTICS
def show_ext_statistics(db):
    init(autoreset=True)
    query = """select extension, count(*), sum(size)/(1024*1024) as mb from other_files group by extension order by mb DESC limit 40;"""
    with contextlib.closing(db.get_sql_cursor(query)) as cursor:
        headers = ["File extension", "File number", "Size (MB)"]
        col_align = ("left", "right", "right")
        data = cursor.fetchall()
        colored_headers = [Fore.GREEN + Style.BRIGHT + headers[0] + Style.RESET_ALL,
                           Style.BRIGHT + headers[1],
                           Fore.RED + Style.BRIGHT + headers[2] + Style.RESET_ALL]
        colored_data = [
            [Fore.GREEN + row[0] + Style.RESET_ALL, row[1], Fore.RED + str(row[2]) + Style.RESET_ALL]
            for row in data
        ]

        print(tabulate(colored_data, colored_headers, tablefmt="pretty", colalign=col_align))
#endregion

#region DB STATISTICS
def show_db_statistics(db):
    init(autoreset=True)
    data = list()
    headers = ["Description", "Value", "Unit"]
    col_align = ("left", "right", "left")

    query = """select count(*), sum(size)/(1024*1024) from books;"""
    n_books = 0
    unique_book_size_mb = 0
    with contextlib.closing(db.get_sql_cursor(query)) as cursor:
        n_books, unique_book_size_mb = cursor.fetchone()

    query = """select count(*), sum(size)/(1024*1024) from archives;"""
    n_archives = 0
    unique_archives_size_mb = 0
    with contextlib.closing(db.get_sql_cursor(query)) as cursor:
        n_archives, unique_archives_size_mb = cursor.fetchone()

    query = """select count(*), sum(size)/(1024*1024) from other_files where status=0;"""
    n_other = 0
    other_size_mb = 0
    with contextlib.closing(db.get_sql_cursor(query)) as cursor:
        n_other, other_size_mb = cursor.fetchone()

    data += [["Number of UNIQUE books (disregards duplicates)", n_books, "items"]]
    data += [["Number of UNIQUE archives (disregards duplicates)", n_archives, "items"]]
    data += [["Number of other files", n_other, "items"]]

    data += [["Size of UNIQUE books (disregards duplicates)", unique_book_size_mb, "MB"]]
    data += [["Size of UNIQUE archives (disregards duplicates)", unique_archives_size_mb, "MB"]]
    data += [["Size of other files", other_size_mb, "MB"]]

    colored_headers = [Fore.GREEN + Style.BRIGHT + headers[0] + Style.RESET_ALL,
                       Fore.RED + Style.BRIGHT + headers[1] + Style.RESET_ALL,
                       Style.BRIGHT + headers[2] + Style.RESET_ALL]
    colored_data = [
        [Fore.GREEN + str(row[0]) + Style.RESET_ALL, Fore.RED + str(row[1]) + Style.RESET_ALL, str(row[2]), ]
        for row in data
    ]

    print(tabulate(colored_data, colored_headers, tablefmt="pretty", colalign=col_align))
#endregion

#region VALIDATE DB
def check_duplicates_in_archive_files(db):
    query = """select archive_files.file_name, count(id) as cnt from archive_files group by file_name having cnt>1;"""
    n = 0
    with contextlib.closing(db.get_sql_cursor(query)) as cursor:
        data = cursor.fetchall()
        for fn, cnt in data:
            n += cnt
    return n

def check_duplicates_in_other_files(db):
    query = """select other_files.path_id, other_files.basename, count(id) as cnt from other_files group by other_files.path_id, other_files.basename having cnt>1;"""
    n = 0
    with contextlib.closing(db.get_sql_cursor(query)) as cursor:
        data = cursor.fetchall()
        for path_id, bn, cnt in data:
            n += cnt
    return n

def check_duplicates_in_book_files(db):
    query = """select book_files.file_name, count(id) as cnt from book_files group by file_name having cnt>1;"""
    n = 0
    with contextlib.closing(db.get_sql_cursor(query)) as cursor:
        data = cursor.fetchall()
        for fn, cnt in data:
            n += cnt
    return n

def validate_db(db):
    print('Database validation:')


    check_text = "duplicates row in book_files table."
    n = check_duplicates_in_book_files(db)
    if n>0:
        logger.print_err(f'[FAIL] {n} {check_text}')
    else:
        logger.print_log(f'[ OK ] No {check_text}')


    check_text = "duplicates row in archive_files table."
    n = check_duplicates_in_archive_files(db)
    if n>0:
        logger.print_err(f'[FAIL] {n} {check_text}')
    else:
        logger.print_log(f'[ OK ] No {check_text}')
    pass


    check_text = "duplicates row in other_files table."
    n = check_duplicates_in_other_files(db)
    if n>0:
        logger.print_err(f'[FAIL] {n} {check_text}')
    else:
        logger.print_log(f'[ OK ] No {check_text}')
    pass


#endregion

#region cPROFILE
def dump_cprofile(db):
    p = pstats.Stats('scanstats')
    p.strip_dirs().sort_stats('cumtime').print_stats()
#endregion

if __name__ == "__main__":
    check_params()
    cmd = sys.argv[2]

    config = BooKeeperConfig(sys.argv[1])
    command = sys.argv[2]
    logger = Logger(log_file=config.log_file_name, level=config.log_level)

    if cmd != OPT_DEL_DUP:
        config.ram_drive_db = ''

    if not is_ramdrive_mounted(config.ram_drive_path):
        logger.print_err(f'ERROR: Ram drive "{config.ram_drive_path}" is not mounted.')
        quit(1)
    elif config.clear_ram_drive_on_start:
        for p in glob.glob(os.path.join(config.ram_drive_path, '*')):
            if os.path.isdir(p):
                shutil.rmtree(p)
            elif os.path.isfile(p):
                os.unlink(p)

    db = BooKeeperDB(db_file_name=config.db_file_name,
                     ram_drive_db=config.ram_drive_db,
                     override_db=config.delete_db_on_start)

    if cmd==OPT_DEL_DUP:
        delete_duplicates(db)
    elif cmd==OPT_EXT_STAT:
        show_ext_statistics(db)
    elif cmd==OPT_VALIDATE:
        validate_db(db)
    elif cmd==OPT_CPROFILE:
        dump_cprofile(db)
    elif cmd==OPT_DB_STAT:
        show_db_statistics(db)

    db.finalize()
